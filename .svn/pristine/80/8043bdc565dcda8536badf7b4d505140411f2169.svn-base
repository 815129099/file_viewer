package com.jjshome.viewer.dao.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import com.jjshome.viewer.dao.FileDao;
import com.jjshome.viewer.model.FileModel;

@Component
public class FileDaoImpl implements FileDao {

	Logger logger = LoggerFactory.getLogger(this.getClass());

	/**
	 * @Fields root : 根路径,每次初始化会清空这个目录
	 */
	@Value("${tmp.root}")
	private String root;

	/**
	 * @Fields id2File : pathid 作为key
	 */
	private Map<String, FileModel> id2File;


	@PostConstruct
	public void init() {
		logger.info("FileDaoImpl init ...");
		// 使用同步的map
		this.id2File = new ConcurrentHashMap<String, FileModel>(
				(int) (32 / 0.7));
		// 根目录初始化
		File file = new File(this.root);
		if (!file.exists()) {
			// 初始化不存在创建目录
			file.mkdirs();
		} else {
			// 存在的话,删除下面的所有内容
			deleteDir(file);
		}
		logger.info("FileDaoImpl init end ...");
	}

	@Override
	public void saveFile(InputStream is, FileModel fileModel) {
		// 获取单次操作唯一目录
		File currDir = getOnlyDir(3, this.root);
		fileModel.setDir(currDir.getAbsolutePath());

		// 获取文件唯一标识(需要找一个好的编码方式,将url进行安全的编码来用做pathid,有待研究)
		fileModel.setPathId(UUID.randomUUID().toString());

		// 存储文件
		FileOutputStream out = null;
		try {
			out = new FileOutputStream(new File(fileModel.getDir() + "/"
					+ fileModel.getOriginalFile()));
			byte[] data = new byte[1024];
			int tmp = 0;
			while ((tmp = is.read(data)) != -1) {
				out.write(data, 0, tmp);
			}
			out.flush();
		} catch (IOException e) {
			throw new RuntimeException(e);
		} finally {
			try {
				if (out != null) {
					out.close();
				}
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}

		// 2个map中filemodel使用同一个对象,修改时会同步变化
		fileModel.setState(FileModel.STATE_YXZ);
		this.id2File.put(fileModel.getPathId(), fileModel);
	}

	/**
	 * @Description: 删除文件夹下所有内容,不会删除文件夹本身
	 * @param dir
	 * @author liaohongwei
	 * @date 2016年6月24日 下午2:52:24
	 */
	private void deleteDir(File dir) {
		if (!dir.isDirectory()) {
			return;
		}
		File[] childs = dir.listFiles();
		for (File child : childs) {
			if (child.isDirectory()) {
				deleteDir(child);
			}
			child.delete();

		}
	}

	/**
	 * @Description: 得到一个唯一的目录
	 * @param num
	 *            重复尝试次数
	 * @param root
	 *            根目录
	 * @return File
	 * @author liaohongwei
	 * @date 2016年6月15日 下午4:46:35
	 */
	private File getOnlyDir(int num, String root) {
		if (num == 0) {
			return null;
		}

		File file = new File(root + "/" + UUID.randomUUID().toString());
		num--;
		if (file.exists()) {
			return getOnlyDir(num, root);
		} else {
			file.mkdirs();
			return file;
		}
	}

	@Override
	public FileModel findByPathId(String pathId) {
		FileModel tmp = this.id2File.get(pathId);
		if (tmp == null) {
			return null;
		} else {
			return tmp.clone();
		}
	}

	@Override
	public FileModel removeFromMap(String pathId) {
		return this.id2File.remove(pathId);
	}

	@Override
	public int rollbackFromMap(FileModel fileModel) {
		this.id2File.put(fileModel.getPathId(), fileModel);
		return 1;
	}

	@SuppressWarnings("static-access")
	@Override
	public int delete(FileModel fileModel) {
		File dir = new File(fileModel.getDir());
		
		// 此处连续尝试删除3次,有可能文件正在被其他线程打开,而删除失败
		for (int i = 0; i < 3; i++) {
			deleteDir(dir);
			boolean flag = dir.delete();
			if(flag){
				// 删除成功,结束循环
				break;
			}
			try {
				Thread.currentThread().sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		if (dir.exists()) {
			// 删除失败
			return 0;
		} else {
			return 1;
		}
	}

	@Override
	public List<String> findAllKeys() {
		List<String> result = new ArrayList<String>();
		result.addAll(this.id2File.keySet());
		return result;
	}

}
